using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net.Http.Headers;
using System.Text;

namespace Cerulean.Analyzer
{
    public class SourceBuilder
    {
        private readonly List<string> _fields = new();
        private readonly SourceSnippet _properties = new();
        private readonly SourceSnippet _methods = new();
        private readonly SourceSnippet _defaultCtor = new();
        private readonly List<string> _usingDirectives = new();
        private readonly List<string> _inheritanceList = new();

        public IReadOnlyList<string> UsingDirectives => _usingDirectives;
        public IReadOnlyList<string> InheritanceList => _inheritanceList;
        public string? Namespace { get; set; }
        public string? ClassName { get; set; }

        public void AddUsingDirective(string usingDirective)
        {
            _usingDirectives.Add(usingDirective);
        }

        public void AddField(string type, string name, string? value = null, string accessModifier = "private", string attribute = "")
        {
            if (!string.IsNullOrEmpty(attribute))
            {
                _fields.Add("[" + attribute + "]");
            }
            _fields.Add($"{accessModifier} {type}{(value is null ? '?' : "")} {name} = {value ?? "null"};");
        }

        public void AddAutoProperty(string type, string name, string? value = null, string? setAccessModifier = null,
            string attribute = "")
        {
            if (!string.IsNullOrEmpty(attribute))
            {
                _fields.Add("[" + attribute + "]");
            }
            _fields.Add($"public {type} {name} {{ get;{setAccessModifier ?? string.Empty} set; }}{(value is not null ? $" = {value};" : "")}");
        }

        public void AddInitProperty(string type, string name, string? value = null, string attribute = "")
        {
            if (!string.IsNullOrEmpty(attribute))
            {
                _fields.Add("[" + attribute + "]");
            }
            _fields.Add($"public {type} {name} {{ get; init; }}{(value is not null ? $" = {value};" : "")}");
        }

        public void AddInheritance(string inheritance)
        {
            _inheritanceList.Add(inheritance);
        }

        public void ClearConstructor()
        {
            _defaultCtor.Clear();
        }

        public void WriteLineToConstructor(params string[] lines)
        {
            foreach (var line in lines)
            {
                _defaultCtor.WriteLine(line);
            }
        }

        public void IncreaseIndentToConstructor()
        {
            _defaultCtor.IncreaseIndent();
        }

        public void DecreaseIndentToConstructor()
        {
            _defaultCtor.DecreaseIndent();
        }

        public void ResetIndentToConstructor()
        {
            _defaultCtor.ResetIndentLevel();
        }

        public string Build(string @namespace = "", string className = "")
        {
            var fileNamespace = string.IsNullOrEmpty(@namespace) ? Namespace : @namespace;
            var fileClassName = string.IsNullOrEmpty(className) ? ClassName : className;
            var inheritance = GetInheritance();

            Logger.WriteLine("Building source... {0}.{1}", fileNamespace ?? "null", fileClassName ?? "null");

            if (string.IsNullOrEmpty(fileNamespace) || string.IsNullOrEmpty(fileClassName))
                throw new ArgumentException("SourceBuilder instance lacks information for class name and namespace.");

            var source = new SourceSnippet();
            foreach (var usingDirective in _usingDirectives)
            {
                source.Write("using ").Write(usingDirective).WriteLine(";");
            }
            source.WriteLine();
            source.WriteLine("// Auto-Generated by Cerulean.Analyzer");
            source.WriteLine($"namespace {fileNamespace}");
            source.WriteLine("{");
            source.IncreaseIndent();

            source.Write($"public class {fileClassName!}");
            if (inheritance is not null)
            {
                source.Write(" : ").Write(inheritance);
            }
            source.WriteLine();
            source.WriteLine("{");
            source.IncreaseIndent();

            // write fields
            source.WriteLines(_fields);
            if (_fields.Count > 0)
                source.WriteLine();

            // write props
            source.WriteLine(_properties);
            if (_properties.Length > 0)
                source.WriteLine();

            // write default ctor
            source.WriteLine($"public {fileClassName!}()");
            source.WriteLine("{");
            source.IncreaseIndent();
            source.WriteLine(_defaultCtor);
            source.DecreaseIndent();
            source.WriteLine("}");
            source.WriteLine();

            // write methods
            source.WriteLine(_methods);

            source.DecreaseIndent();
            source.WriteLine("}");

            source.DecreaseIndent();
            source.WriteLine("}");

            return source.ToString();
        }

        public override string ToString()
        {
            Logger.WriteLine("Invoked SourceBuilder.ToString();");
            if (string.IsNullOrEmpty(Namespace) || string.IsNullOrEmpty(ClassName))
            {
                Logger.WriteLine("Invalid namespace or class name for source builder");
                return string.Empty;
            }

            return Build(Namespace!, ClassName!);
        }

        private string? GetInheritance()
        {
            if (_inheritanceList.Count == 0)
                return null;

            var builder = new StringBuilder();
            for (var i = 0; i < _inheritanceList.Count; ++i)
            {
                builder.Append(_inheritanceList[i]);
                if (i != _inheritanceList.Count - 1)
                    builder.Append(", ");
            }

            return builder.ToString();
        }
    }

    internal class SourceSnippet
    {
        private const int MAX_INDENT = 1024;
        private const int MIN_INDENT = 0;

        private readonly StringBuilder _builder = new();
        private int _indentLevel;
        private readonly int _defaultIndentLevel;
        private bool _lastIsNewLine = true;

        public int IndentWidth { get; set; } = 4;

        public int Length => _builder.Length;

        public SourceSnippet(int indentLevel = 0)
        {
            _defaultIndentLevel = Max(MIN_INDENT, indentLevel);
            _indentLevel = _defaultIndentLevel;
        }

        public SourceSnippet ResetIndentLevel()
        {
            _indentLevel = _defaultIndentLevel;

            return this;
        }

        public SourceSnippet IncreaseIndent()
        {
            _indentLevel += _indentLevel >= MAX_INDENT ? 0 : 1;

            return this;
        }

        public SourceSnippet DecreaseIndent()
        {
            _indentLevel -= _indentLevel <= Max(MIN_INDENT, _defaultIndentLevel) ? 0 : 1;

            return this;
        }

        public SourceSnippet WriteLine(string? text = null, params object[] args)
        {
            for (var i = 0; i < _indentLevel * IndentWidth; i++)
            {
                _builder.Append(' ');
            }

            if (text is null)
            {
                _builder.AppendLine();
            }
            else
            {
                _builder.AppendLine(args.Length > 0 ? string.Format(text, args) : text);
            }
            _lastIsNewLine = true;

            return this;
        }

        public SourceSnippet WriteLine(SourceSnippet sourceSnippet)
        {
            var source = sourceSnippet.ToString().Replace("\r", "").Split(
                new[] {'\n' },
                StringSplitOptions.RemoveEmptyEntries
            );
            foreach (var line in source)
            {
                WriteLine(line);
            }

            return this;
        }

        public SourceSnippet WriteLines(IEnumerable<string> lines)
        {
            foreach (var line in lines)
            {
                WriteLine(line);
            }

            return this;
        }

        public SourceSnippet Write(string text, params object[] args)
        {
            for (var i = 0; i < _indentLevel * IndentWidth && _lastIsNewLine; i++)
            {
                _builder.Append(' ');
            }

            _builder.Append(args.Length > 0 ? string.Format(text, args) : text);
            _lastIsNewLine = false;

            return this;
        }

        public SourceSnippet Clear()
        {
            _builder.Clear();
            _indentLevel = 0;

            return this;
        }

        public override string ToString()
        {
            return _builder.ToString();
        }

        private static int Max(int a, int b)
            => a > b ? a : b;
    }
}